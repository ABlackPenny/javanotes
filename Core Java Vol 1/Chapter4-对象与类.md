# 对象与类

> Key points：类

## 4.1 面向对象程序设计（OOP）概述

- 程序由对象组成，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。
- 先考虑组织数据，再考虑操作数据的算法

### 4.1.1 类（class）

- *类*是构造对象的模版或蓝图。由类*构造*（construct）对象的过程称为创建类的*实例*（instance）。
- *封装*（encapsulation，有时称为数据隐藏）是与对象有关的一个重要概念。对象中的数据称为*实例域*（instance field），操纵数据的过程称为*方法*（method）。对于每个特定的类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前*状态*（state）。
- Java 中，所有的类都源于一个超类Object。

### 4.1.2 对象

- *对象的行为*（behavior）：
- *对象的状态*（state）：
- *对象标识*（identity）：

- 作为一个类的实例，每个对象的标识永远不同，状态也常常存在差异。

### 4.1.3 识别类

- 从设计类开始，再往每个类中添加方法。
- 经验：名词很可能成为类；动词很可能是方法。

### 4.1.4 类之间的关系



## 4.2 使用预定义类

- 并非所有类都具有面向对象的特征，如Math类只需要知道方法名和参数即可。

### 4.2.1 对象与对象变量

- 要想使用对象，必须首先构造对象，并指定其初始状态，然后对对象应用方法。
- 使用*构造器*（constructor）构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。
- 构造器的名字应该与类名相同。创建对象时使用关键字new。
- 对象与对象变量的区别：
- Java 中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。

### 4.2.2 Java 类库中的 LocalDate 类

### 4.2.3 更改器方法与访问器方法

- 更改器方法（mutator method）：
- 访问器方法（accessor method）：



## 4.3 用户自定义类

### 4.3.1 Employee 类

- Example：参见P103的 Employee 类

```java
class ClassName {
  field1
  field2
    ...
  constructor1
  constructor2
    ...
  method1
  method2
}
```

- 在一个源文件中，只能有一个公有类（与源文件名相同），可以有任意数目的非公有类。

### 4.3.2 多个源文件的使用

### 4.3.3 剖析 Employee 类

- 关键字 public 意味着任何类的任何方法都可以调用这些方法。
- 实例域：建议标为 private。

### 4.3.4 从构造器开始

- 在构造 Employee 类的对象时，构造器会运行，以便将实例域初始化为所希望的状态。
- 构造器总是伴随着 new 操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。
- 构造器与类同名
- 每个类可以有一个以上的构造器
- 构造器可以有0、1或多个参数
- 构造器没有返回值

### 4.3.5 隐式（implicit）参数与显式（explicit）参数

- 方法用于操作对象以及存取它们的实例域。
- 在每一个方法中，关键字 this 表示隐式参数。

### 4.3.6 封装的优点

- 获得或设置实例域的值，需要提供以下三项：
  - 一个私有的数据域
  - 一个公有的域访问器方法
  - 一个公有的域更改器方法

### 4.3.7 基于类的访问权限

- 方法可以访问所调用对象的私有数据，即可以访问所属类的所有对象的私有数据。

### 4.3.8 私有方法

- 实现一个私有的方法：只需将 public 改为 private。
- 只要方法是私有的，类的设计者就可以确信：它不会被外部的其他类操作调用，可以改将其删去。如果方法是公有的，就不能将其删去，因为其他的代码很可能依赖它。

### 4.3.9 final 实例域

- 可以将实例域定义为 final，后面的操作中就无法再对其进行修改。
- final 修饰符大多应用于 primitive 类型域，或*不可变*（immutable）类的域（如果类中的每个方法都不会改变其对象，这种类就是不可变的类，如 String 类）



## 4.4 静态域与静态方法

### 4.4.1 静态域

```java
class Employee{
  private static int nextID = 1;
  private int id;
  ...
}
```

- 每个雇员对象都有一个自己的id域，但这个类的所有实例将共享一个 nextID 域。如果有1000个 Employee 类的对象，则有1000个实例域id，但是只有一个静态域 nextID。
- 静态域属于类，而不属于任何独立的对象。

### 4.4.2 静态常量

- 如 Math 类中的 PI：

```java
public class Math {
  public static final double PI = 3.14159265358979323846;
}
```

### 4.4.3 静态方法

- 静态方法是一种不能向对象实施操作的方法。可以认为静态方法是没有 this 参数的方法。
- Employee 类的静态方法不能访问 id 实例域，因为它不能操作对象。但是静态方法可以访问自身类中的静态域，如nextID。
- 在以下两种情况下使用静态方法：
  - 一个方法不需要访问对象状态，其所需参数都是通过显式参数提供，如 Math.pow；
  - 一个方法只需要访问类的静态域。

### 4.4.4 工厂方法（factory method）

- 类似 LocalDate 和 NumberFormat的类使用静态工厂方法来构造对象，参见P115。

### 4.4.5 main 方法

- main 方法不对任何对象进行操作
- 每一个类可以有一个 main 方法，这是一个常用的对类进行单元测试的技巧。



## 4.5 方法参数

- Java 总是按值调用（call by value）
- 具体🌰见P118-123



## 4.6 对象构造

### 4.6.1 重载（overloading）

- 有些类有多个构造器，这种特征叫做重载。
- Java 允许重载任何方法，而不只是构造器方法。
- 不能有两个名字相同，参数类型也相同但返回值类型不同的方法。

### 4.6.2 默认域初始化

- 如果在构造器中没有显式地给域赋予初值，那么域初始化成默认值：数值为0、布尔值为 false、对象引用为 null。

### 4.6.3 无参数的构造器

- 仅当类没有提供任何构造器的时候系统才会提供一个默认的构造器。这个构造器将所有的实例域设置为默认值。

### 4.6.4 显式域初始化

- 初始值不一定是常量值，也可以调用方法对域进行初始化。

### 4.6.5 参数名

```java
public Employee(String aName, double aSalary) {
  name = aName;
  salary = aSalary;
}
```

或者

```java
public Employee(String name, double salary) {
  // 关键字 this 引用方法对隐式参数
  this.name = name;
  this.salary = salary;
}
```

### 4.6.6 调用另一个构造器

```java
public Employee(double s) {
  // calls Employee(String, double) 
  // 如果构造器的第一个语句形如 this(...) 这个构造器将调用同一个类的另一个构造器
  this("Employee #" + nextID, s);
  nextID++;
}
```

### 4.6.7 初始化块

- review 两种初始化数据域的方法：
  - 在构造器中设置值
  - 在声明中赋值
- 第三种：*初始化块*（initialization block），建议将初始化块放在域定义之后

### 4.6.8 对象析构与 finalize 方法



## 4.7 *包*（package）

使用包可以确保类名的唯一性。

### 4.7.1 类的导入

- 一个类可以使用所属包中的所有类，以及其他包中的公有类（public class）。

### 4.7.2 

